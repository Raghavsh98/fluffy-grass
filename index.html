<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluffy Grass</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #f1f1f1;
            font-family: Arial, sans-serif;
        }
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 18px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="loading">Loading Fluffy Grass...</div>
    <canvas id="canvas"></canvas>
    
    <!-- Load Three.js and dependencies -->
    <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.159.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.159.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.159.0/examples/js/math/MeshSurfaceSampler.js"></script>
    
    <script>
        // Remove loading message
        document.querySelector('.loading').style.display = 'none';
        
        // Grass Material class
        class GrassMaterial {
            constructor() {
                this.material = new THREE.MeshLambertMaterial({
                    side: THREE.DoubleSide,
                    color: 0x229944,
                    transparent: true,
                    alphaTest: 0.1,
                    shadowSide: 1,
                });
                this.uniforms = {
                    uTime: { value: 0 },
                    uEnableShadows: { value: true },
                    uShadowDarkness: { value: 0.5 },
                    uGrassLightIntensity: { value: 0.7 },
                    uNoiseScale: { value: 2.4 },
                    uPlayerPosition: { value: new THREE.Vector3() },
                    baseColor: { value: new THREE.Color("#313f1b") },
                    tipColor1: { value: new THREE.Color("#9bd38d") },
                    tipColor2: { value: new THREE.Color("#1f352a") },
                    noiseTexture: { value: new THREE.Texture() },
                    grassAlphaTexture: { value: new THREE.Texture() },
                };
                this.setupGrassMaterial(this.material);
            }

            update(delta) {
                this.uniforms.uTime.value = delta;
            }

            setupGrassMaterial(material) {
                material.onBeforeCompile = (shader) => {
                    shader.uniforms = {
                        ...shader.uniforms,
                        uTime: this.uniforms.uTime,
                        uTipColor1: this.uniforms.tipColor1,
                        uTipColor2: this.uniforms.tipColor2,
                        uBaseColor: this.uniforms.baseColor,
                        uEnableShadows: this.uniforms.uEnableShadows,
                        uShadowDarkness: this.uniforms.uShadowDarkness,
                        uGrassLightIntensity: this.uniforms.uGrassLightIntensity,
                        uNoiseScale: this.uniforms.uNoiseScale,
                        uNoiseTexture: this.uniforms.noiseTexture,
                        uGrassAlphaTexture: this.uniforms.grassAlphaTexture,
                    };

                    shader.vertexShader = `
                        #include <common>
                        #include <fog_pars_vertex>
                        #include <shadowmap_pars_vertex>
                        uniform sampler2D uNoiseTexture;
                        uniform float uNoiseScale;
                        uniform float uTime;
                        
                        varying vec3 vColor;
                        varying vec2 vGlobalUV;
                        varying vec2 vUv;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vWindColor;
                        
                        void main() {
                            #include <color_vertex>
                            #include <begin_vertex>
                            #include <project_vertex>
                            #include <fog_vertex>
                            #include <beginnormal_vertex>
                            #include <defaultnormal_vertex>
                            #include <worldpos_vertex>
                            #include <shadowmap_vertex>

                            vec2 uWindDirection = vec2(1.0,1.0);
                            float uWindAmp = 0.1;
                            float uWindFreq = 50.;
                            float uSpeed = 1.0;
                            float uNoiseFactor = 5.50;
                            float uNoiseSpeed = 0.001;

                            vec2 windDirection = normalize(uWindDirection);
                            vec4 modelPosition = modelMatrix * instanceMatrix * vec4(position, 1.0);

                            float terrainSize = 100.;
                            vGlobalUV = (terrainSize-vec2(modelPosition.xz))/terrainSize;

                            vec4 noise = texture2D(uNoiseTexture,vGlobalUV+uTime*uNoiseSpeed);

                            float sinWave = sin(uWindFreq*dot(windDirection, vGlobalUV) + noise.g*uNoiseFactor + uTime * uSpeed) * uWindAmp * (1.-uv.y);

                            float xDisp = sinWave;
                            float zDisp = sinWave;
                            modelPosition.x += xDisp;
                            modelPosition.z += zDisp;

                            modelPosition.y += exp(texture2D(uNoiseTexture,vGlobalUV * uNoiseScale).r) * 0.5 * (1.-uv.y);

                            vec4 viewPosition = viewMatrix * modelPosition;
                            vec4 projectedPosition = projectionMatrix * viewPosition;
                            gl_Position = projectedPosition;

                            vUv = vec2(uv.x,1.-uv.y);
                            vNormal = normalize(normalMatrix * normal);
                            vWindColor = vec2(xDisp,zDisp);
                            vViewPosition = mvPosition.xyz;
                        }
                    `;

                    shader.fragmentShader = `
                        #include <alphatest_pars_fragment>
                        #include <alphamap_pars_fragment>
                        #include <fog_pars_fragment>
                        #include <common>
                        #include <packing>
                        #include <lights_pars_begin>
                        #include <shadowmap_pars_fragment>
                        #include <shadowmask_pars_fragment>
                        
                        uniform float uTime;
                        uniform vec3 uBaseColor;
                        uniform vec3 uTipColor1;
                        uniform vec3 uTipColor2;
                        uniform sampler2D uGrassAlphaTexture;
                        uniform sampler2D uNoiseTexture;
                        uniform float uNoiseScale;
                        uniform int uEnableShadows;
                        uniform float uGrassLightIntensity;
                        uniform float uShadowDarkness;
                        
                        varying vec3 vColor;
                        varying vec2 vUv;
                        varying vec2 vGlobalUV;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vWindColor;
                        
                        void main() {
                            vec4 grassAlpha = texture2D(uGrassAlphaTexture,vUv);
                            vec4 grassVariation = texture2D(uNoiseTexture, vGlobalUV * uNoiseScale);
                            vec3 tipColor = mix(uTipColor1,uTipColor2,grassVariation.r);
                            
                            vec4 diffuseColor = vec4( mix(uBaseColor,tipColor,vUv.y), step(0.1,grassAlpha.r) );
                            vec3 grassFinalColor = diffuseColor.rgb * uGrassLightIntensity;
                            
                            vec3 geometryPosition = vViewPosition;
                            vec3 geometryNormal = vNormal;
                            vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
                            vec3 geometryClearcoatNormal;
                            IncidentLight directLight;
                            float shadow = 0.0;
                            float currentShadow = 0.0;
                            float NdotL;
                            
                            if(uEnableShadows == 1){
                                #if ( NUM_DIR_LIGHTS > 0) 
                                    DirectionalLight directionalLight;
                                #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
                                    DirectionalLightShadow directionalLightShadow;
                                #endif
                                    #pragma unroll_loop_start
                                    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
                                        directionalLight = directionalLights[ i ];
                                        getDirectionalLightInfo( directionalLight, directLight );
                                        directionalLightShadow = directionalLightShadows[ i ];
                                        currentShadow = getShadow( directionalShadowMap[ i ], 
                                            directionalLightShadow.shadowMapSize, 
                                            directionalLightShadow.shadowBias, 
                                            directionalLightShadow.shadowRadius, 
                                            vDirectionalShadowCoord[ i ] );
                                        currentShadow = all( bvec2( directLight.visible, receiveShadow ) ) ? currentShadow : 1.0;
                                        float weight = clamp( pow( length( vDirectionalShadowCoord[ i ].xy * 2. - 1. ), 4. ), .0, 1. );
                                        shadow += mix( currentShadow, 1., weight);
                                    }
                                    #pragma unroll_loop_end
                                #endif
                                grassFinalColor = mix(grassFinalColor , grassFinalColor * uShadowDarkness,  1.-shadow) ;
                            } else{
                                grassFinalColor = grassFinalColor ;
                            }
                            diffuseColor.rgb = clamp(diffuseColor.rgb*shadow,0.0,1.0);

                            #include <alphatest_fragment>
                            gl_FragColor = vec4(grassFinalColor ,1.0);
                            
                            #include <tonemapping_fragment>
                            #include <colorspace_fragment>
                            #include <fog_fragment>
                        }
                    `;
                };
            }

            setupTextures(grassAlphaTexture, noiseTexture) {
                this.uniforms.grassAlphaTexture.value = grassAlphaTexture;
                this.uniforms.noiseTexture.value = noiseTexture;
            }
        }

        // Main scene setup
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        
        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(21.43, 4.51, -7.31);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // Background and fog
        scene.background = new THREE.Color('#eeeeee');
        scene.fog = new THREE.FogExp2('#eeeeee', 0.045989);
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
        directionalLight.castShadow = true;
        directionalLight.position.set(100, 100, 100);
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        directionalLight.shadow.mapSize.set(2048, 2048);
        scene.add(directionalLight);
        
        // Create sky
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 0.5);
                }
            `,
            uniforms: {
                topColor: { value: new THREE.Color(0x87CEEB) },
                bottomColor: { value: new THREE.Color(0xE0F6FF) },
                offset: { value: 33 },
                exponent: { value: 0.6 }
            },
            side: THREE.BackSide
        });
        
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);
        
        // Load textures and create grass material
        const textureLoader = new THREE.TextureLoader();
        const grassMaterial = new GrassMaterial();
        
        // Load textures
        const perlinNoise = textureLoader.load('./perlinnoise.webp');
        perlinNoise.wrapS = perlinNoise.wrapT = THREE.RepeatWrapping;
        const grassAlpha = textureLoader.load('./grass.jpeg');
        
        grassMaterial.setupTextures(grassAlpha, perlinNoise);
        
        // Create simple terrain and grass for now
        const terrainGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
        const terrainMaterial = new THREE.MeshPhongMaterial({ color: '#5e875e' });
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.receiveShadow = true;
        scene.add(terrain);
        
        // Create grass blades
        const grassCount = 8000;
        const grassGeometry = new THREE.PlaneGeometry(0.1, 2);
        const grassInstancedMesh = new THREE.InstancedMesh(grassGeometry, grassMaterial.material, grassCount);
        grassInstancedMesh.receiveShadow = true;
        
        const matrix = new THREE.Matrix4();
        for (let i = 0; i < grassCount; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 80,
                1,
                (Math.random() - 0.5) * 80
            );
            const rotation = new THREE.Euler(0, Math.random() * Math.PI * 2, 0);
            const scale = new THREE.Vector3(1, 1, 1);
            
            matrix.compose(position, new THREE.Quaternion().setFromEuler(rotation), scale);
            grassInstancedMesh.setMatrixAt(i, matrix);
        }
        
        scene.add(grassInstancedMesh);
        
        // Animation
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            grassMaterial.update(delta);
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>